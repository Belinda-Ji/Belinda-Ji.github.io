<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="数据结构,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="[TOC] https://github.com/Belinda-Ji/LeetCode 【动态规划dp】5.最长回文子串 状态：dp[i][j]代表以i开头j结尾的子串是否是回文串。记录最长子串的长度max。 转移方程 ：dp[i][j]=1 if i==j or (j-i==1 and s[i]==s[j]) or (s[i]==s[j] and dp[i+1][j-1]==1) 初始条件和边">
<meta name="keywords" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷题笔记">
<meta property="og:url" content="http://yoursite.com/post/LeetCodeNotes.html">
<meta property="og:site_name" content="秘密花园">
<meta property="og:description" content="[TOC] https://github.com/Belinda-Ji/LeetCode 【动态规划dp】5.最长回文子串 状态：dp[i][j]代表以i开头j结尾的子串是否是回文串。记录最长子串的长度max。 转移方程 ：dp[i][j]=1 if i==j or (j-i==1 and s[i]==s[j]) or (s[i]==s[j] and dp[i+1][j-1]==1) 初始条件和边">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-05-09T09:14:46.784Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode刷题笔记">
<meta name="twitter:description" content="[TOC] https://github.com/Belinda-Ji/LeetCode 【动态规划dp】5.最长回文子串 状态：dp[i][j]代表以i开头j结尾的子串是否是回文串。记录最长子串的长度max。 转移方程 ：dp[i][j]=1 if i==j or (j-i==1 and s[i]==s[j]) or (s[i]==s[j] and dp[i+1][j-1]==1) 初始条件和边">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/post/LeetCodeNotes.html">





  <title> LeetCode刷题笔记 | 秘密花园 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">秘密花园</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">永远自由自我  永远高唱我歌</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/post/LeetCodeNotes.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="瓶子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秘密花园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                LeetCode刷题笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-09T17:02:34+08:00">
                2021-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法基础/" itemprop="url" rel="index">
                    <span itemprop="name">算法基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/Belinda-Ji/</span>LeetCode</span><br></pre></td></tr></table></figure>
<h3 id="【动态规划dp】"><a href="#【动态规划dp】" class="headerlink" title="【动态规划dp】"></a>【动态规划dp】</h3><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h4><ul>
<li>状态：<code>dp[i][j]</code>代表以i开头j结尾的子串是否是回文串。记录最长子串的长度max。</li>
<li>转移方程 ：<code>dp[i][j]=1 if i==j or (j-i==1 and s[i]==s[j]) or (s[i]==s[j] and dp[i+1][j-1]==1)</code></li>
<li>初始条件和边界条件：<code>dp[i][i]==1</code> <code>i&lt;=j</code></li>
<li>由于在计算<code>dp[i][j]</code>之前要知道<code>dp[i+1][j-1]</code>，因此i从大到小遍历，j从小到大遍历。</li>
<li>时间复杂度：O(mn)，空间复杂度：O(mn)</li>
</ul>
<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h4><ul>
<li>状态：<code>dp[j]</code>代表以j结尾的最大子序和，最后<code>max(dp[j])</code>即为所求解。</li>
<li>转移方程：<code>dp[j]=max(dp[j-1]+s[j],s[j])</code></li>
<li>初始条件和边界条件：<code>dp[0]=s[0]</code></li>
<li>时间复杂度：O(n)，空间复杂度：O(n)</li>
</ul>
<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h4><ul>
<li>状态：<code>dp[i]</code>代表青蛙能跳到第i个石头</li>
<li>转移方程：<code>dp[j]=1 if dp[i]=1 and a[i]&gt;=j-i for i&lt;j</code>，双层遍历，<code>j in (0,n),i in (0,j)</code>，第二层循环中只要有一个满足条件就break。</li>
<li>初始条件和边界条件：<code>dp[0]=1, dp[1]=1 if a[0]&gt;=1, dp[2]=(dp[0]=1 and a[0]&gt;=2) or (dp[1]=1 and a[1]&gt;=1)</code></li>
<li>时间复杂度：O(n2)，空间复杂度：O(n)</li>
</ul>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h4><ul>
<li>状态：<code>dp[i][j]</code>代表机器人走到第ij个格子有多少种路径。</li>
<li>转移方程：<code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></li>
<li>初始条件和边界条件：<code>dp[0][0]=1,dp[0][:]=1,dp[:][0]=1</code></li>
<li>时间复杂度：O(mn)，空间复杂度：O(mn)</li>
</ul>
<h4 id="63-不同路径II"><a href="#63-不同路径II" class="headerlink" title="63.不同路径II"></a>63.不同路径II</h4><ul>
<li>状态：<code>dp[i][j]</code>代表机器人走到第ij个格子有多少种路径。</li>
<li>转移方程：对于有障碍物的格子，<code>dp[i][j]</code>=0，否则，<code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></li>
<li><strong>初始条件和边界条件</strong>：<code>if a[0][0]==0:dp[0][0]=1,if a[0][j]==0:dp[0][j]=1 if dp[0][j-1]=1 else 0,if a[i][0]==0:dp[i][0]=1 if a[i-1][0]=1 else 0</code></li>
<li>时间复杂度：O(mn)，空间复杂度：O(mn)</li>
</ul>
<h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a>64.最小路径和</h4><ul>
<li>状态：<code>dp[i][j]</code>代表走到第ij个格子的最小路径和。</li>
<li>转移方程：<code>dp[i][j]=min(dp[i-1][j],dp[i][j-1])+nums[i][j]</code></li>
<li>初始条件和边界条件：<code>dp[0][0]=nums[0][0], dp[0][j]=dp[0][j-1]+nums[0][j], dp[i][0]=dp[i-1][0]+nums[i][0]</code></li>
<li>时间复杂度：O(mn)，空间复杂度：O(mn)</li>
</ul>
<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h4><ul>
<li>状态：<code>dp[i]</code>代表爬到第i个楼梯有几种方式</li>
<li>转移方程：<code>dp[i]=dp[i-1]+dp[i-2]</code></li>
<li>初始条件和边界条件：<code>dp[0]=0,dp[1]=1,dp[2]=2,dp[3]=dp[1]+dp[2]=3</code></li>
<li>时间复杂度：O(n)，空间复杂度：O(n)</li>
</ul>
<h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152.乘积最大子数组"></a>152.乘积最大子数组</h4><ul>
<li>如果当前值为负数，则前一个乘积越小越好，如果当前值为正数，则前一个乘积越大越好，因此要记录两个状态。</li>
<li>状态：<code>maxdp[i]</code>代表以i结尾的子数组乘积最大值，<code>mindp[i]</code>代表以i结尾的子数组乘积最小值</li>
<li>转移方程：<code>maxdp[i]=max(maxdp[i-1]*nums[i],nums[i],mindp[i-1]*nums[i]), mindp[i]=min(mindp[i-1]*nums[i], nums[i], maxdp[i-1]*nums[i])</code></li>
<li>初始条件和边界条件：<code>maxdp[0]=nums[0], mindp[0]=nums[0]</code></li>
<li>时间复杂度：O(n)，空间复杂度：O(n)，可优化成O(1)，maxdp/mindp只记录当前最大值/最小值。</li>
</ul>
<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h4><ul>
<li>状态：<code>dp[i]</code>代表打劫i个房子能获得的最大金额</li>
<li>转移方程：<code>dp[i]=max(dp[i-2]+nums[i],dp[i-1])</code>，由于不能打劫相邻房子，所以最后的状态可以选择打劫i-1或者不打劫i-1。</li>
<li>初始条件和边界条件：<code>dp[0]=nums[0],dp[1]=max(dp[0],nums[1])</code></li>
<li>时间复杂度：O(n)，空间复杂度：O(n)</li>
</ul>
<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h4><ul>
<li>状态：<code>dp[i]</code>代表以i结尾的最长递增子序列的长度</li>
<li>转移方程：遍历比i小的位置，<code>if a[j]&gt;=a[i]:dp[j]=max(dp[j],dp[i]+1)</code></li>
<li>初始条件和边界条件：<code>dp[i]=1 for i in (0,n);dp[1]=dp[0]+1 if a[1]&gt;=a[0] else 1</code></li>
<li>时间复杂度：O(n2)，空间复杂度：O(n)</li>
</ul>
<h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h4><ul>
<li>状态：拼出i最少需要<code>dp[i]</code>枚硬币</li>
<li>转移方程：<code>dp[k]=min(dp[k-a[i]] for i in range(len(a)))+1</code></li>
<li>初始条件和边界条件：<code>dp[0]=0,dp[a[i]]=1 for i in range(len(a)),dp[i]=sys.maxsize if i&lt;0</code></li>
<li>时间复杂度：O(kn)，空间复杂度O(n)</li>
</ul>
<h4 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368.最大整除子集**"></a>368.最大整除子集**</h4><ul>
<li>对数组进行排序</li>
<li>状态：<code>dp[i]</code>代表以第i个元素结尾的最大整除子集的长度，<code>last[i]</code>代表以第i个元素结尾的最大整除子集的上一个元素。</li>
<li>转移方程：遍历比j小的元素位置i，如果<code>nums[j]%nums[i]==0 and dp[j]&lt;dp[i]+1</code>，将j接在i的最大整除子集的后面，<code>last[j]=i</code></li>
<li>初始条件和边界条件：<code>dp[0]=1,dp[1]=2 if nums[1]%nums[0]==0,res=[0,1]</code>，最后从<code>dp[i]</code>中找出最大的i，并根据last数组找到最大整除子集的所有元素。</li>
<li>时间复杂度：O(n2)，空间复杂度：O(n)</li>
</ul>
<h4 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403.青蛙过河**"></a>403.青蛙过河**</h4><ul>
<li>状态：<code>dp[i][k]</code>代表能通过跳跃k步到达第i个石子。</li>
<li>转移方程：<code>dp[j][k-1] or dp[j][k] or dp[j][k+1]</code>且<code>stone[i]-stone[j]=k</code>，即青蛙能通过k-1或k或k+1步跳到第j个石子。</li>
<li>k的取值范围是单元格的个数，i的取值范围是有石子的个数。双层遍历，遍历比i小的所有j，<code>k=stone[i]-stone[j]</code>，如果<code>dp[j][k] or dp[j][k-1] or dp[j][k+1]</code>有一个为<code>True</code>则<code>dp[i][k]=True</code>。</li>
<li>初始条件和边界条件：<code>dp[0][0]=True</code>，<code>dp[1][1]=True if stone[1]==1</code></li>
<li>时间复杂度：O(mn)，空间复杂度：O(mn)</li>
</ul>
<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516.最长回文子序列**"></a>516.最长回文子序列**</h4><ul>
<li>状态：<code>dp[i][j]</code>代表i到j的最长回文子序列的长度。</li>
<li>转移方程：如果<code>s[i]==s[j]</code>，那么<code>dp[i][j]=dp[i+1][j-1]+2</code>，如果<code>s[i]!=s[j]</code>，那么<code>dp[i][j]=max(dp[i][j-1], dp[i+1][j])</code>，因为 [i+1,j-1]可能前面加一个字符或者后面加一个字符能组成回文序列。</li>
<li>初始条件和边界条件：<code>dp[i][i]=1 for all i; dp[0][1]=2 if s[0]==s[1]</code>，i从大到小遍历，j从小到大遍历，且i&lt;=j。</li>
<li>时间复杂度：O(n2)，空间复杂度：O(n2)。</li>
</ul>
<h4 id="542-01矩阵"><a href="#542-01矩阵" class="headerlink" title="542.01矩阵"></a>542.01矩阵</h4><ul>
<li>状态：<code>dp[i][j]</code>代表<code>mat[i][j]</code>和0的距离</li>
<li>转移方程：<code>dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i+1][j],dp[i][j+1])+1</code></li>
<li>上述转移方程不方便遍历，将其拆解成两步，先从上向下从左向右遍历得到<code>min(dp1[i-1][j],dp1[i][j-1])</code>, 再从下向上从右向左遍历得到<code>min(dp2[i+1][j],dp2[i][j+1])</code></li>
<li>再根据dp1和dp2的值从上向下，从右向左遍历一次。</li>
<li>时间复杂度：O(n2)，空间复杂度：O(n2)</li>
</ul>
<h4 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650.只有两个键的键盘"></a>650.只有两个键的键盘</h4><ul>
<li>状态：打印出i个A需要<code>dp[i]</code>步</li>
<li>转移方程：对于所有比i小的数j，假如j是i的约数，那么从j到i需要复制一次+粘贴i/j-1次=i/j步，即<code>dp[j]=dp[i]+i//j</code>，如果i是个质数，那么打印出i个A需要复制一次+粘贴i-1次=i步</li>
<li>边界条件和初始条件：<code>dp[1]=0,dp[2]=2</code></li>
<li>时间复杂度：O(n^2)，空间复杂度：O(n)</li>
</ul>
<h4 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673.最长递增子序列的个数**"></a>673.最长递增子序列的个数**</h4><ul>
<li>状态：以i结尾的最长递增子序列的长度为<code>length[i]</code>，最长递增子序列的个数为<code>count[i]</code>。</li>
<li>转移方程：遍历比i小的j，找到满足<code>nums[j]&lt;=nums[i]</code>的最大的length[j]，将i接在j后面，更新<code>length[i]=length[j]+1</code>，找到所有满足<code>nums[j]&lt;=nums[i]</code>且<code>length[j]=max_length_j</code>的j，将子序列个数相加即为<code>count[i]</code>。</li>
<li>初始条件和边界条件：<code>length[0]=1,count[0]=1</code></li>
<li>时间复杂度：O(n2) ，空间复杂度：O(n)</li>
</ul>
<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h4><ul>
<li>状态：<code>dp[i]</code>代表爬到i级楼梯使用的最小花费。最终求<code>dp[n-1]</code></li>
<li>转移方程：<code>dp[i]=min(dp[i-1],dp[i-2])+cost[i]</code></li>
<li>初始条件和边界条件：<code>dp[0]=cost[0],dp[1]=cost[1],dp[2]=min(dp[0],dp[1])+cost[2]</code></li>
<li>时间复杂度：O(n)，空间复杂度：O(n)</li>
</ul>
<h4 id="背包01问题"><a href="#背包01问题" class="headerlink" title="背包01问题"></a>背包01问题</h4><ul>
<li>状态：<code>dp[i][j]</code>代表前i个物品总重量不超过j时的最大价值</li>
<li>转移方程：如果放进第i个物品，则<code>dp[i][j]=dp[i-1][j-wi]+vi</code>，如果不放进第i个物品，则<code>dp[i][j]=dp[i-1][j]</code></li>
<li>初始条件和边界条件：<code>dp[0][:]=0,dp[1][j]=v1 if w1&lt;=j else 0</code></li>
<li>时间复杂度：O(mn)，空间复杂度：O(mn)</li>
</ul>
<h4 id="最长公共子数组的长度"><a href="#最长公共子数组的长度" class="headerlink" title="最长公共子数组的长度"></a>最长公共子数组的长度</h4><ul>
<li>状态：<code>dp[i][j]</code>代表以数组A的第i个元素结尾的子数组和以数组B的第j个元素结尾的子数组的最长公共子数组的长度</li>
<li>转移方程：<code>if a[i]==b[j]:dp[i][j]=dp[i-1][j-1]+1, else:dp[i][j]=max(dp[i-1][j],dp[i][j-1])</code></li>
<li>初始条件和边界条件：<code>dp[0][0]=1 if a[0]==b[0] else 0</code>,<code>dp[0][1]=1 if a[0]==b[0] or a[0]==b[1] else 0</code>,<code>dp[1][0]=1 if a[0]==b[0] or a[1]==b[0]</code></li>
<li>时间复杂度：O(mn)，空间复杂度：O(mn)</li>
</ul>
<h3 id="【堆heap】"><a href="#【堆heap】" class="headerlink" title="【堆heap】"></a>【堆heap】</h3><h4 id="215-K个元素的最小堆"><a href="#215-K个元素的最小堆" class="headerlink" title="215.K个元素的最小堆"></a>215.K个元素的最小堆</h4><h4 id="1046-最后一块石头的权重"><a href="#1046-最后一块石头的权重" class="headerlink" title="1046.最后一块石头的权重"></a>1046.最后一块石头的权重</h4><h3 id="【其它other】"><a href="#【其它other】" class="headerlink" title="【其它other】"></a>【其它other】</h3><h4 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr"></a>28.实现strStr</h4><h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h4><h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h4><h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h4><h4 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58.最后一个单词的长度"></a>58.最后一个单词的长度</h4><h4 id="402-移掉K维数字"><a href="#402-移掉K维数字" class="headerlink" title="402.移掉K维数字"></a>402.移掉K维数字</h4><h4 id="441-排列硬币"><a href="#441-排列硬币" class="headerlink" title="441.排列硬币"></a>441.排列硬币</h4><h4 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448.找到所有数组中消失的数字"></a>448.找到所有数组中消失的数字</h4><h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h4><ul>
<li>每次尽量用最小的饼干去满足最小胃口的孩子，饼干用掉之后就不能用了。</li>
</ul>
<h4 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h4><h3 id="【指针pointer】"><a href="#【指针pointer】" class="headerlink" title="【指针pointer】"></a>【指针pointer】</h3><h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h4><ul>
<li>对数组进行排序</li>
<li>每次固定第一个数i，将左指针指向i+1的位置，右指针指向数组末尾位置。判断三数之和与target的关系，如果小于target，将左指针向右移一位，如果大于target，将右指针向左移一位，如果等于target，将当前三个数加入到结果数组中。</li>
<li>剪枝：如果第一个数i的值大于target，无须向后遍历。</li>
<li>去重：如果第一个数等于它前一个数，则跳过；如果当前左指针的值等于它前一个位置的值（不包括第一个数），则跳过；如果当前右指针的值等于它后一个位置的值，则跳过。</li>
<li>时间复杂度：O(n^2)，空间复杂度：O(1)</li>
</ul>
<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h4><ul>
<li>对数组进行排序，记录target和前三个数之和的diff。</li>
<li>每次固定第一个数，将左指针指向i+1的位置，右指针指向数组末尾位置。判断三数之和与target的diff是否更小，如果是则更新这个diff。判断三数之和与target的关系，如果小于target，将左指针向右移一位，如果大于target，将右指针向左移一位。</li>
<li>返回与target的diff最小的三数之和。</li>
<li>时间复杂度：O(n^2)，空间复杂度：O(1)</li>
</ul>
<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h4><ul>
<li>对数组进行排序</li>
<li>前两个数双层遍历，后两个数用左右双指针，方法同三数之和。</li>
<li><p>剪枝：</p>
<ul>
<li>如果从i开始的连续四个数之和大于target，说明找不到等于target的四数了，退出第一层循环。</li>
<li>如果从j开始的连续三个数加上第1个数之和大于target，说明找不到等于target的四数了，跳出第二层循环。</li>
</ul>
</li>
<li><p>去重</p>
<ul>
<li>两层循环去重：当前值等于前一个值就跳过</li>
<li>双指针去重：左指针：当前值等于前一个值就跳过，右指针：当前值等于后一个值就跳过</li>
</ul>
</li>
</ul>
<h4 id="26-删除有序数组的重复值"><a href="#26-删除有序数组的重复值" class="headerlink" title="26.删除有序数组的重复值"></a>26.删除有序数组的重复值</h4><ul>
<li>使用快慢两个指针i和j，同时指向第一个元素。</li>
<li>当nums[i]==nums[j]时，j向后移动；当nums[i]!=nums[j]时，将nums[j]覆盖掉nums[i+1],i向后移一位。</li>
<li>终止条件：当j到达终点时停止。</li>
</ul>
<h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h4><ul>
<li>两个指针同时指向第一个元素</li>
<li>只要指针2不等于val，就用指针2的值覆盖指针1的值，并将指针1后移一步</li>
<li>指针2每次都后移一步</li>
<li>终止条件：指针2到达终点</li>
</ul>
<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h4><ul>
<li>两个指针分别代表区间左边界和右边界</li>
<li>先对区间按照第一个元素进行排序</li>
<li>左指针指向第一个区间的左边界，判断第二个区间的左边界是否&lt;=第一个区间的右边界。<ul>
<li>如果是，右指针指向【区间一的右边界和区间二的右边界的较大者】。继续判断第三个区间的左边界和右指针指向值的大小。</li>
<li>如果不是，则将前一个左右指针存储起来，左指针移到第二个区间的左边界。</li>
</ul>
</li>
<li>终止条件：所有区间遍历完成。</li>
</ul>
<h4 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86.分隔链表"></a>86.分隔链表</h4><ul>
<li>创建两个链表small和large，分别用于存储比x小的值和比x大的值</li>
<li>遍历链表，如果节点值比x小，则将节点连接到small的后面，head指针后跳一位，small指针后跳一位</li>
<li>如果节点值比x大，则将节点连接到large后面，head指针后跳一位，large指针后跳一位。</li>
<li>如果head已遍历完，将large的最后一个next指针置为None，并将small的next指针指向large。</li>
</ul>
<h4 id="283-移动零元素"><a href="#283-移动零元素" class="headerlink" title="283.移动零元素"></a>283.移动零元素</h4><ul>
<li>设置左右两个指针，都指向第一个元素。</li>
<li>左指针:只有左右指针都指向零时，左指针才不需要后移。</li>
<li>右指针在任何情况都需要后移。</li>
</ul>
<h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h4><p>[1] 双指针</p>
<ul>
<li>两个指针p1和p2分别指向s和t的开头</li>
<li>如果p1和p2元素相等，两指针都向后走一步；如果不相等，p2向后走一步</li>
<li>终止条件:p1,p2有一个大于等于字符串长度，即其中一个字符串已遍历完。</li>
<li>判断结果：如果p1&gt;=n1，返回True；否则说明s还没遍历完，t已经遍历完了，返回False;</li>
<li>时间复杂度：O(max(n1,n2)),空间复杂度：O(1)</li>
</ul>
<p>[2] 动态规划</p>
<ul>
<li>状态：<code>dp[i][j]</code>表示s的前i个字符串是否是t的前j个字符串的子序列</li>
<li>转移方程：<br>如果<code>s[i]==s[j]</code>且<code>dp[i-1][j-1]=True</code>, 那么<code>dp[i][j]=True</code><br>如果<code>s[i]!=s[j]</code>且<code>dp[i][j-1]=True</code>,那么<code>dp[i][j]=True</code><br>其它情况都返回False</li>
<li>边界条件：<br><code>dp[0][0]= True if s[0]==t[0] else False</code><br><code>dp[0][j]=True if dp[0][j-1] or s[0]=t[j] else False</code></li>
<li>时间复杂度: O(n1n2),空间复杂度O(n1n2)</li>
</ul>
<h3 id="【递归recursive】"><a href="#【递归recursive】" class="headerlink" title="【递归recursive】"></a>【递归recursive】</h3><h4 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29.两数相除"></a>29.两数相除</h4><ul>
<li>递归函数内部，令d=divisor, 不断对d翻倍（d=d+d)，直到d&gt;dividend为止，记下翻倍次数count</li>
<li>递归执行func(dividend-d, divisor)</li>
</ul>
<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h4><ul>
<li>递归法：<ul>
<li>设置变量res记录结果集合，path记录当前递归的路径，candidates为可用数组，target记录当前剩余数，</li>
<li>遍历candidates中的每一个元素a，递归调用dfs(candidates, target-a, path+[a], res, begin)</li>
<li>终止条件：如果target==0则将path添加到res中并return，如果target小于0，直接return</li>
<li>由于解集合不能包含重复的组合，递归时下一层从上一层元素开始向后遍历，不考虑前面的元素，设置begin指示开始遍历点。</li>
</ul>
</li>
</ul>
<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h4><ul>
<li>递归法：遍历左子树，打印val，遍历右子树。</li>
<li>非递归法：<ul>
<li>1不断将左子树放入栈中，直到左子树为空。</li>
<li>2当栈不为空时，从栈顶取出一个节点，打印节点值，再从右子树开始，重复步骤1。</li>
<li>3终止条件：栈为空且节点为null。</li>
</ul>
</li>
</ul>
<h4 id="96-不同的二叉搜索树的个数"><a href="#96-不同的二叉搜索树的个数" class="headerlink" title="96.不同的二叉搜索树的个数"></a>96.不同的二叉搜索树的个数</h4><ul>
<li>递归法：超时</li>
<li>动态规划：记录以i个元素构造的二叉搜索树的个数为<code>dp[i]</code>，则以j个元素构造的二叉搜索树的个数等于分别以每一个元素作为根结点分裂二叉树形成的左子树和右子树的dp之积，<code>dp[l]*dp[r]</code></li>
<li>卡特兰数：<code>f[n] = sum(f[i], f[n-i-1]) for i in range(0,n)</code></li>
</ul>
<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h4><ul>
<li>非递归法：<ul>
<li>1将根节点放入栈中</li>
<li>2从栈中弹出栈底元素，打印val，再分别将它的左子树和右子树push到栈中</li>
<li>3每次弹出栈底元素之前判断栈中元素的个数n，循环弹出n个栈底元素，执行步骤2，并记录该层的元素</li>
</ul>
</li>
</ul>
<h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h4><ul>
<li>递归法：<ul>
<li>打印val，遍历左子树，遍历右子树。</li>
</ul>
</li>
<li>非递归法：<ul>
<li>1打印val，不断遍历左子树，每遍历一次就打印val，并将其放入栈中，直到左子树为空。</li>
<li>2从栈中弹出栈顶元素，再从右子树开始，重复步骤1。</li>
<li>3终止条件：栈为空且节点为null。</li>
</ul>
</li>
</ul>
<h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h4><ul>
<li>递归法：<ul>
<li>遍历左子树，遍历右子树，打印val</li>
</ul>
</li>
<li>非递归法：将后序遍历的左右中转化成中右左的前序遍历，再将结果逆转。<ul>
<li>1打印val，不断遍历右子树，每遍历一次就打印val，并将右子树推入栈中，直到右子树为空。</li>
<li>2从栈中弹出栈顶元素，再从左子树开始，重复步骤1。</li>
<li>3终止条件：栈为空且节点为null。</li>
<li>4逆转结果数组。</li>
</ul>
</li>
</ul>
<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h4><ul>
<li>dfs遍历</li>
<li>用一个矩阵记录一个点是否被搜索过</li>
<li>如果碰到岛屿，则将它上下左右四个方向全都搜索一遍，并将矩阵对应位置的状态改成1</li>
<li>遍历grid，只有在当前点是岛屿且没有被搜索过时才搜索当前点，并将岛屿数量加1</li>
</ul>
<h4 id="236-最小公共祖先"><a href="#236-最小公共祖先" class="headerlink" title="236.最小公共祖先"></a>236.最小公共祖先</h4><ul>
<li>遍历二叉树，用hash表存下每个节点的父节点</li>
<li>从hash表中不断查找p节点的父节点，找到p的所有祖先，存入数组中（包括p节点自身）</li>
<li>从hash表中不断查找q节点的父节点，如果它在2中的数组中出现过则返回该节点，即为最小公共祖先。</li>
</ul>
<h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h4><ul>
<li>递归法：<ul>
<li>递归遍历二叉树，得到每个结点的深度，根结点的深度等于左右子树的深度的较大者加1</li>
<li>以当前结点为根结点的直径等于左子树的深度加上右子树的深度再加1</li>
<li>每一层遍历得到根结点的直径都与最大值作比较，取较大者。</li>
</ul>
</li>
</ul>
<h3 id="【搜索search】"><a href="#【搜索search】" class="headerlink" title="【搜索search】"></a>【搜索search】</h3><h4 id="二分查找有序数组"><a href="#二分查找有序数组" class="headerlink" title="二分查找有序数组"></a>二分查找有序数组</h4><ul>
<li>递归法：<ul>
<li>找到数组的中点</li>
<li>递归查找左半数组</li>
<li>递归查找右半数组</li>
<li>一旦找到target即返回</li>
</ul>
</li>
<li>非递归法：<ul>
<li>设置两个指针begin和end分别指向数组的头尾</li>
<li>判断中点mid=begin+(end-begin)//2元素和target的大小，如果小于target，则begin=mid+1，如果大于target则end=mid-1，如果等于target直接返回mid</li>
</ul>
</li>
</ul>
<h4 id="34-二分查找第一个等于target的元素位置"><a href="#34-二分查找第一个等于target的元素位置" class="headerlink" title="34.二分查找第一个等于target的元素位置"></a>34.二分查找第一个等于target的元素位置</h4><ul>
<li>如果mid元素等于target，要查找的元素一定在[left, mid]区间内</li>
<li>如果mid元素大于target，要查找的元素一定在[left, mid]区间内</li>
<li>如果mid元素小于target，要查找的元素一定在[mid+1, right]区间内</li>
<li>mid=left+(right-left)//2</li>
</ul>
<h4 id="34-二分查找最后一个等于target的元素位置"><a href="#34-二分查找最后一个等于target的元素位置" class="headerlink" title="34.二分查找最后一个等于target的元素位置"></a>34.二分查找最后一个等于target的元素位置</h4><ul>
<li>如果mid元素等于target，要查找的元素一定在[mid, right]区间内</li>
<li>如果mid元素大于target，要查找的元素一定在[left, mid-1]区间内</li>
<li>如果mid元素小于target，要查找的元素一定在[mid, right]区间内</li>
<li>mid=left+(right-left+1)//2</li>
</ul>
<h4 id="287-找到唯一一个重复数字"><a href="#287-找到唯一一个重复数字" class="headerlink" title="287.找到唯一一个重复数字"></a>287.找到唯一一个重复数字</h4><ul>
<li>二分查找1到n</li>
<li>每次查找mid时遍历数组，记录数组中小于等于mid的元素个数count。如果count大于mid，即数组中小于等于mid的数量比mid大，说明重复数字在1到mid之间；如果count小于等于mid，即数组中小于等于mid的数量不比mid大，说明重复数字在mid+1到n之间。</li>
</ul>
<h3 id="【滑动窗口sliding-window】"><a href="#【滑动窗口sliding-window】" class="headerlink" title="【滑动窗口sliding window】"></a>【滑动窗口sliding window】</h3><h4 id="438-所有的字母异位词"><a href="#438-所有的字母异位词" class="headerlink" title="438.所有的字母异位词"></a>438.所有的字母异位词</h4><ul>
<li>用一个size为26的数组记录子串各字母出现大的次数</li>
<li>每次滑动窗口，并更新计数数组，比较子串和目标字符串是否是字母异位词</li>
</ul>
<h4 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423.可获得的最大点数"></a>1423.可获得的最大点数</h4><ul>
<li>转化成求剩余卡牌的最小点数问题</li>
<li>长度为k的滑动窗口，记录初始和，每次滑动时减掉左边元素加上右边元素</li>
</ul>
<h4 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438.绝对差不超过限制的最长连续子数组"></a>1438.绝对差不超过限制的最长连续子数组</h4><ul>
<li>用一个有序集合存储窗口内的元素（sortedcontainers in python），右指针不断右移，判断窗口内的绝对差（最大最小值之差）是否满足条件，如果不满足条件则将左边元素移除直到满足条件为止。</li>
<li>记录每个满足条件的窗口的长度，替换最大长度。</li>
</ul>
<h3 id="【排序sort】"><a href="#【排序sort】" class="headerlink" title="【排序sort】"></a>【排序sort】</h3><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><ul>
<li>从头开始遍历，比较后一个元素和前一个元素，将较大的元素交换到后面。</li>
<li>每遍历完一次数组后，最大元素就到了末尾位置，再从头开始遍历，直到倒数第二个位置。</li>
<li>以此类推。</li>
<li>时间复杂度：O(n2)，空间复杂度：O(1)</li>
</ul>
<h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h4><ul>
<li>类似打扑克时摸牌，从第二个元素i开始，每次将i与前面i-1个元素逐个向前比较，插入到正确位置。</li>
<li>由于步骤1中会不断修改元素i的指针，因此要提前记录i所属的位置，下次操作从i+1位置开始。</li>
<li>以此类推。</li>
<li>时间复杂度：最坏情况下数组是逆序的，需要遍历1+2+ ……+n次，O(n2)，空间复杂度：O(1)</li>
</ul>
<h4 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3.快速排序"></a>3.快速排序</h4><ul>
<li>每次选择一个轴点元素，将小于轴点的元素全部放在其左边，大于轴点的元素放在其右边。</li>
<li>递归操作，分别对轴点左边的数组和轴点右边的数组进行重复步骤1，步骤1需要返回轴点元素的位置。</li>
<li>时间复杂度：O(nlogn)，空间复杂度：O(1)</li>
</ul>
<h4 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4.选择排序"></a>4.选择排序</h4><ul>
<li>每次遍历时从数组中选择最大的元素，将其和末尾元素交换。</li>
<li>下次遍历时从剩下的n-1个元素中找到最大元素，与倒数第二个位置元素交换。</li>
<li>以此类推。</li>
<li>时间复杂度：O(n2)，空间复杂度：O(1)</li>
</ul>
<h4 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h4><ul>
<li>递归操作，选择数组中点，分别对数组左半边和右半边进行排序，再合并左半边和右半边数组。</li>
<li>合并时，将左数组复制一份new_arr，用两个指针分别指向new_arr和右数组的开头，左数组也设置一个开头指针，每次选择较小者插入到左数组中，同时移动左数组指针和插入数组的指针。</li>
<li>提前停止：如果new_arr指针到终点了，右数组剩下的元素留在原地，合并结束。如果右数组到终点了，将new_arr拷贝至末尾。</li>
<li>时间复杂度：O(nlogn)，空间复杂度：O(n)</li>
</ul>
<h4 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75.颜色分类"></a>75.颜色分类</h4><ul>
<li>设置两个指针，一个指向开头，一个指向结尾。</li>
<li>遍历一遍，如果等于0，将其与开头指针元素交换，0指针向后移一位，遍历指针i+1</li>
<li>如果等于1，不操作，遍历指针i+1</li>
<li>如果等于2，将其与结尾指针元素交换，结尾指针向前移一位，遍历指针i不变（因为交换回来的元素可能还需要交换）</li>
</ul>
<h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148.排序链表"></a>148.排序链表</h4><ul>
<li>归并排序</li>
<li>用快慢指针寻找链表的中点，并递归地寻找子链表的中点，直到只有一个结点为止</li>
<li>合并两个有序链表，一直向上回溯到返回结果</li>
</ul>
<h3 id="【栈stack】"><a href="#【栈stack】" class="headerlink" title="【栈stack】"></a>【栈stack】</h3><h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h4><ul>
<li>设计一个支持 push，pop，top操作，并能在常数时间内检索到最小元素的栈。</li>
<li>用一个辅助栈，用来存储当前栈每个位置对应的最小值。</li>
<li>新元素入栈时，取该元素与辅助栈栈顶元素之间的最小值插入到辅助栈栈顶</li>
<li>有元素出栈时，辅助栈的元素也弹出栈。</li>
</ul>
<h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394.字符串解码"></a>394.字符串解码</h4><ul>
<li>通过一个栈来存储当前的res和倍数</li>
<li>如果当前为数字，记录当前数字为倍数multi；如果当前为左括号，将当前的res和multi放入栈中；如果当前为字母，记录到res中；如果当前为右括号，pop出栈顶元素res和multi，新的res=res+multi*当前res。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/BatchNorm.html" rel="next" title="Batch Normalization">
                <i class="fa fa-chevron-left"></i> Batch Normalization
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="瓶子">
          <p class="site-author-name" itemprop="name">瓶子</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Belinda-Ji" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
	


	<div id="music163player">
	     <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="220" height="32" src="//music.163.com/outchain/player?type=2&id=420401255&auto=0&height=32">
	     </iframe>
        </div>
	
	


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#【动态规划dp】"><span class="nav-number">1.</span> <span class="nav-text">【动态规划dp】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-最长回文子串"><span class="nav-number">1.1.</span> <span class="nav-text">5.最长回文子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-最大子序和"><span class="nav-number">1.2.</span> <span class="nav-text">53.最大子序和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55-跳跃游戏"><span class="nav-number">1.3.</span> <span class="nav-text">55.跳跃游戏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62-不同路径"><span class="nav-number">1.4.</span> <span class="nav-text">62.不同路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#63-不同路径II"><span class="nav-number">1.5.</span> <span class="nav-text">63.不同路径II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64-最小路径和"><span class="nav-number">1.6.</span> <span class="nav-text">64.最小路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#70-爬楼梯"><span class="nav-number">1.7.</span> <span class="nav-text">70.爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#152-乘积最大子数组"><span class="nav-number">1.8.</span> <span class="nav-text">152.乘积最大子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#198-打家劫舍"><span class="nav-number">1.9.</span> <span class="nav-text">198.打家劫舍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#300-最长递增子序列"><span class="nav-number">1.10.</span> <span class="nav-text">300.最长递增子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#322-零钱兑换"><span class="nav-number">1.11.</span> <span class="nav-text">322.零钱兑换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#368-最大整除子集"><span class="nav-number">1.12.</span> <span class="nav-text">368.最大整除子集**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#403-青蛙过河"><span class="nav-number">1.13.</span> <span class="nav-text">403.青蛙过河**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#516-最长回文子序列"><span class="nav-number">1.14.</span> <span class="nav-text">516.最长回文子序列**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#542-01矩阵"><span class="nav-number">1.15.</span> <span class="nav-text">542.01矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#650-只有两个键的键盘"><span class="nav-number">1.16.</span> <span class="nav-text">650.只有两个键的键盘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#673-最长递增子序列的个数"><span class="nav-number">1.17.</span> <span class="nav-text">673.最长递增子序列的个数**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#746-使用最小花费爬楼梯"><span class="nav-number">1.18.</span> <span class="nav-text">746.使用最小花费爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#背包01问题"><span class="nav-number">1.19.</span> <span class="nav-text">背包01问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长公共子数组的长度"><span class="nav-number">1.20.</span> <span class="nav-text">最长公共子数组的长度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【堆heap】"><span class="nav-number">2.</span> <span class="nav-text">【堆heap】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#215-K个元素的最小堆"><span class="nav-number">2.1.</span> <span class="nav-text">215.K个元素的最小堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1046-最后一块石头的权重"><span class="nav-number">2.2.</span> <span class="nav-text">1046.最后一块石头的权重</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【其它other】"><span class="nav-number">3.</span> <span class="nav-text">【其它other】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#28-实现strStr"><span class="nav-number">3.1.</span> <span class="nav-text">28.实现strStr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35-搜索插入位置"><span class="nav-number">3.2.</span> <span class="nav-text">35.搜索插入位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#48-旋转图像"><span class="nav-number">3.3.</span> <span class="nav-text">48.旋转图像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49-字母异位词分组"><span class="nav-number">3.4.</span> <span class="nav-text">49.字母异位词分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58-最后一个单词的长度"><span class="nav-number">3.5.</span> <span class="nav-text">58.最后一个单词的长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#402-移掉K维数字"><span class="nav-number">3.6.</span> <span class="nav-text">402.移掉K维数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#441-排列硬币"><span class="nav-number">3.7.</span> <span class="nav-text">441.排列硬币</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#448-找到所有数组中消失的数字"><span class="nav-number">3.8.</span> <span class="nav-text">448.找到所有数组中消失的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#455-分发饼干"><span class="nav-number">3.9.</span> <span class="nav-text">455.分发饼干</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#738-单调递增的数字"><span class="nav-number">3.10.</span> <span class="nav-text">738.单调递增的数字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【指针pointer】"><span class="nav-number">4.</span> <span class="nav-text">【指针pointer】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-三数之和"><span class="nav-number">4.1.</span> <span class="nav-text">15.三数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-最接近的三数之和"><span class="nav-number">4.2.</span> <span class="nav-text">16.最接近的三数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-四数之和"><span class="nav-number">4.3.</span> <span class="nav-text">18.四数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-删除有序数组的重复值"><span class="nav-number">4.4.</span> <span class="nav-text">26.删除有序数组的重复值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-移除元素"><span class="nav-number">4.5.</span> <span class="nav-text">27.移除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#56-合并区间"><span class="nav-number">4.6.</span> <span class="nav-text">56.合并区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#86-分隔链表"><span class="nav-number">4.7.</span> <span class="nav-text">86.分隔链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#283-移动零元素"><span class="nav-number">4.8.</span> <span class="nav-text">283.移动零元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#392-判断子序列"><span class="nav-number">4.9.</span> <span class="nav-text">392.判断子序列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【递归recursive】"><span class="nav-number">5.</span> <span class="nav-text">【递归recursive】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#29-两数相除"><span class="nav-number">5.1.</span> <span class="nav-text">29.两数相除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39-组合总和"><span class="nav-number">5.2.</span> <span class="nav-text">39.组合总和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#94-二叉树的中序遍历"><span class="nav-number">5.3.</span> <span class="nav-text">94.二叉树的中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#96-不同的二叉搜索树的个数"><span class="nav-number">5.4.</span> <span class="nav-text">96.不同的二叉搜索树的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#102-二叉树的层序遍历"><span class="nav-number">5.5.</span> <span class="nav-text">102.二叉树的层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#144-二叉树的前序遍历"><span class="nav-number">5.6.</span> <span class="nav-text">144.二叉树的前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#145-二叉树的后序遍历"><span class="nav-number">5.7.</span> <span class="nav-text">145.二叉树的后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#200-岛屿数量"><span class="nav-number">5.8.</span> <span class="nav-text">200.岛屿数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#236-最小公共祖先"><span class="nav-number">5.9.</span> <span class="nav-text">236.最小公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#543-二叉树的直径"><span class="nav-number">5.10.</span> <span class="nav-text">543.二叉树的直径</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【搜索search】"><span class="nav-number">6.</span> <span class="nav-text">【搜索search】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二分查找有序数组"><span class="nav-number">6.1.</span> <span class="nav-text">二分查找有序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-二分查找第一个等于target的元素位置"><span class="nav-number">6.2.</span> <span class="nav-text">34.二分查找第一个等于target的元素位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-二分查找最后一个等于target的元素位置"><span class="nav-number">6.3.</span> <span class="nav-text">34.二分查找最后一个等于target的元素位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#287-找到唯一一个重复数字"><span class="nav-number">6.4.</span> <span class="nav-text">287.找到唯一一个重复数字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【滑动窗口sliding-window】"><span class="nav-number">7.</span> <span class="nav-text">【滑动窗口sliding window】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#438-所有的字母异位词"><span class="nav-number">7.1.</span> <span class="nav-text">438.所有的字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1423-可获得的最大点数"><span class="nav-number">7.2.</span> <span class="nav-text">1423.可获得的最大点数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1438-绝对差不超过限制的最长连续子数组"><span class="nav-number">7.3.</span> <span class="nav-text">1438.绝对差不超过限制的最长连续子数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【排序sort】"><span class="nav-number">8.</span> <span class="nav-text">【排序sort】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-冒泡排序"><span class="nav-number">8.1.</span> <span class="nav-text">1.冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-插入排序"><span class="nav-number">8.2.</span> <span class="nav-text">2.插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-快速排序"><span class="nav-number">8.3.</span> <span class="nav-text">3.快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-选择排序"><span class="nav-number">8.4.</span> <span class="nav-text">4.选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-归并排序"><span class="nav-number">8.5.</span> <span class="nav-text">5.归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#75-颜色分类"><span class="nav-number">8.6.</span> <span class="nav-text">75.颜色分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#148-排序链表"><span class="nav-number">8.7.</span> <span class="nav-text">148.排序链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【栈stack】"><span class="nav-number">9.</span> <span class="nav-text">【栈stack】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#155-最小栈"><span class="nav-number">9.1.</span> <span class="nav-text">155.最小栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#394-字符串解码"><span class="nav-number">9.2.</span> <span class="nav-text">394.字符串解码</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  路途中遇到的闪闪发光的人，都如星辰般照亮我的前路。
<!-- <span class="author" itemprop="copyrightHolder">瓶子</span>
-->
</div>


<!-- <div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>
-->

<!-- <div class="theme-info">
  主题 -
  take a try
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>
-->



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
